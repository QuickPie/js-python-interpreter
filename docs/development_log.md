# 开发日志

> 本开发日志记录从 2026-01-16 以后的对此项目的所有改动（项目创建时间远早于 2026-01-16）。

![版本号](https://img.shields.io/badge/项目当前版本-1.2.5-blue)

# 2026-01-16 ☀ 😊

**里程碑**：语法分析器必需构架全部完成

**具体修改**

1. **语法分析器**：完善缩进与块处理部分

**注意事项**

1. 关于语法分析器中的块处理部分，目前仅识别形式，暂不考虑应用到具体语句中（如 if 语句、 for 语句）

# 2026-01-17 ⛅ 😪

**新添**：完成解释器必需构架

**补充**：完善`README.md`

**启动**：开始写内置函数和调用表达式`CallExpression`

**具体修改**

1. 添加`Environment`类
2. 添加解释器必需构架
4. 添加`Builtins`类和`CallExpression`AST节点
3. 完善`README.md`

**心得**：解释器其实就是用`===`判断当前AST节点类型，再执行或求值；内置函数就是存储在全局作用域里的标识符，只不过当函数使用

# 2026-01-18 🌥️ 😎

**新增**：4种token类型、调用表达式的语法分析支持、`print`函数逻辑

**完善**：`CallExpression`AST节点

**具体修改**

1. **`ast_nodes.js`**：增加`CallExpression`类
2. **`builtins.js`**：添加`print`内置函数逻辑（`createPrint()`）和`internalToString()`
3. **`token.js` `token_patterns.js`**：添加`, = ( )`4种token类型和匹配模板（都是为了调用表达式）

**心得**

词法分析器、语法分析器、解释器三者的框架是最难的，接下来添加新语法就非常简单了！通用的就4步：

1. 添加token
2. 添加AST节点
3. 添加语法分析器逻辑
4. 添加解释器逻辑

# 2026-1-19 ❄ 好多作业📚😧

**新增**：调用表达式语法分析支持（`parseCallExpression()`）和解释器支持（`evalCallExpression()`）

**心情**：开心到飞起✈️🤩

# 2026-1-20 🌨❄❄❄ 😊

**修改**：改善README.md

## 2026-1-21 ☀ ☺️

**紧急修改**：发现之前的分号（`;`）逻辑错误！根本没有“空语句”一说！

**连接应用控制器**：将解释器应用到`main.js`中，并添加显示输出代码

**具体修改**

1. 核心源码
  * 删除`EmptyStatement`AST节点
  * 修改`TokenType.SEMICOLON`的语法分析逻辑
  * 删除`EmptyStatement`的解释器逻辑
  * 添加`scopeName`属性至`Environment`类和`PyError`类
2. 应用控制器
  * 调用解释器并显示输出结果

**心得**：修改分号语法分析逻辑时，改爽了！一个接一个的 bug 涌过来，在浏览器中查看调试器、控制台，然后在代码里修改，再运行试验，一轮接一轮。

# 2026-1-22 🤔 

**思考如何写数据类型**（难）

# 2026-1-24 😀💡

**不对！我用的是内部值，不需要 Python 类型啊！**（恍然大悟）

**添加**：在`Builtins`类中添加`getType()`方法

**具体修改**

* 添加`getType()`方法和`toArray()`方法至`Builtins`类
* 添加内置函数支持：`abs()` `all()`

# 2026-1-25 😊

**添加内置函数**：`any()`

发现 bug！还没支持列表、元组等容器，`all()`和`any()`就执行不了！

**计划草稿**（语法分析）

重点在于区分各种括号被用于列表、元组、字典、集合时和被用于其他语法时的形式。（暂且不需完成的语法就都是以后的事，现在先列出来）

方括号的用法：**列表字面量**、列表索引/切片、列表推导式

圆括号的用法：~~**元组字面量**~~、函数定义/调用、改变表达式优先级、生成器

**正确逻辑应该是：除了空元组，其他元组都不是由圆括号构造的，而是由逗号构造的。**

花括号的用法：**字典字面量**、**集合字面量**、集合推导式、字典推导式

***注：`{}`是字典***

**具体修改**

* **`token.js` `token_patterns.js`**：添加`[ ] { }`4种token类型和匹配模板
* **`ast_nodes.js`**：添加`ListLiteral` `TupleLiteral` `DictLiteral` `SetLiteral`4种AST节点

# 2026-1-26 😊😃 🌤

**添加**：`parseListLiteral()`方法，支持列表字面量

接着昨天对元组真正构造的理解，正在实现元组时，突然发现：

**问题**：我写的语法分析器是通过**标记驱动**的——根据标记直接分发到相应解析方法。这跟较经典的**优先级爬升**式——从优先级最低的表达式开始解析，再往优先级更高的表达式爬升解析，不一样！我的这种**无法直接解析到元组中间的逗号**！

**解决办法**：只好使用优先级驱动式的了……不，我有一计！分两级，把逗号和原来的`parseExpression()`区分开就行了，类似于：**元组的逗号是优先级最低的运算符，其他表达式都是优先级最高的**。

# 2026-1-27 😥 🌤

**添加支持**：元组的语法解析

# 2026-1-28 😥 ⛅

**添加支持**：字典、集合的语法解析（添加`parseDictOrSetLiteral()`方法）

# 2026-1-29 😆😎 放寒假啦！

正在为内置类型发愁，一直搞不明白，不知道如何下手。直到今天看完了 JS 犀牛书第 9 章《类》，终于有自己的想法了，终于知道代码大概的样子了。

**添加**：`PyList`类、`PyTuple`类、`PyDict`类、`PySet`类

# 2026-1-30 😊

**新建**：`hash_manager.js`里的`HashManager`类，负责管理各个对象的哈希

**TODO**：添加网页界面的**设置模块**，可用于设置环境变量

**心得**：写`HashManager`类的`#hashNumber()`方法时，我用我的 PyCharm（一款 Python 集成编辑器）不停的写测试代码，运行参考结果，不断调整测试数值。例如在找浮点数的哈希的规律时，我就写了以下测试代码：

```python
print(2**61-1,(2**61-1)*2)  # 梅森质数
print(hash(1.001),(2**61-1)*0.001)  # 将 hash(n) 尝试通过数值的方式表示出来
print(hash(2.001),(2**61-1)*0.001+1)
print(hash(3.001),(2**61-1)*0.001+2)
print(hash(1.002),(2**61-1)*0.002)
```

不过最后还是用了一点黑科技，简化了一下。

---

## 🎯 开发进度

| 项目 | 状态 |
|------|------|
| 基础字面量 | 完成 |
| 列表、元组、字典、集合| 未完成 |
| 标识符 | 完成 |
| 内置函数 | 开发未完成 |
| 调用表达式 | 完成 |
| 四种基础容器字面量 | 开发未完成 |
| 变量声明语句 | 未开发 |
| 函数声明语句 | 未开发 |
